<!doctype html>
<html lang="pt">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>DXF Viewer (2D - @dxfjs/parser)</title>
        <link
            rel="icon"
            href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Crect width='32' height='32' fill='%23111'/%3E%3Ctext x='50%25' y='50%25' dy='.35em' text-anchor='middle' fill='%23ddd' font-family='monospace' font-size='16'%3ED%3C/text%3E%3C/svg%3E"
        />
        <style>
            :root {
                color-scheme: dark;
            }
            html,
            body {
                margin: 0;
                height: 100%;
                background: #111;
                color: #ddd;
                font-family:
                    system-ui,
                    -apple-system,
                    "Segoe UI",
                    Roboto,
                    "Helvetica Neue",
                    Arial,
                    sans-serif;
                overflow: hidden;
            }
            #topbar {
                position: fixed;
                z-index: 10;
                top: 8px;
                left: 8px;
                right: 8px;
                display: flex;
                gap: 8px;
                align-items: center;
                background: rgba(0, 0, 0, 0.35);
                padding: 6px 8px;
                border-radius: 8px;
                flex-wrap: wrap;
            }
            #topbar input[type="file"],
            #topbar button {
                background: #222;
                color: #ddd;
                border: 1px solid #444;
                padding: 6px 10px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                min-height: 36px;
                touch-action: manipulation;
            }
            #topbar button:active {
                background: #333;
            }
            #topbar button.active {
                background: #0a84ff;
                border-color: #0a84ff;
                color: #fff;
            }
            @media (max-width: 600px) {
            }
            #viewer {
                position: fixed;
                left: 0;
                right: 0;
                top: 0;
                bottom: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
            #status {
                position: fixed;
                left: 50%;
                top: 16px;
                transform: translateX(-50%);
                z-index: 20;
                padding: 8px 12px;
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.65);
                color: #ffd;
                display: none;
                max-width: 70vw;
                text-align: center;
                white-space: pre-wrap;
            }
            .measure-icon {
                width: 18px;
                height: 18px;
                vertical-align: middle;
                margin-right: 4px;
            }
            #measureToolbar {
                display: none;
                position: fixed;
                z-index: 25;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                padding: 16px 20px;
                border-radius: 12px;
                border: 2px solid #0a84ff;
                text-align: center;
                min-width: 280px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            }
            #measureToolbar.active {
                display: block;
            }
            #measureInstructions {
                font-size: 14px;
                margin-bottom: 8px;
                color: #aaa;
            }
            #measureResult {
                margin-top: 8px;
                font-size: 18px;
                font-weight: bold;
                color: #0a84ff;
                min-height: 24px;
            }
            #cancelMeasure {
                margin-top: 12px;
                background: #d32f2f;
                color: #fff;
                border: none;
                padding: 10px 16px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 14px;
                min-height: 40px;
                touch-action: manipulation;
                width: 100%;
            }
            #cancelMeasure:active {
                background: #b71c1c;
            }
        </style>
    </head>
    <body>
        <div id="topbar">
            <input id="file" type="file" accept=".dxf" />
            <button id="fit">Enquadrar</button>
            <button id="measureBtn">
                <svg
                    class="measure-icon"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                >
                    <path
                        d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"
                    />
                </svg>
                Medir
            </button>
        </div>
        <div id="viewer"></div>
        <div id="status"></div>
        <div id="measureToolbar">
            <div id="measureInstructions">Clique no primeiro ponto</div>
            <div id="measureResult"></div>
            <button id="cancelMeasure">Cancelar / Nova Medição</button>
        </div>
        <div
            id="measurement"
            style="
                display: none;
                position: fixed;
                z-index: 30;
                padding: 6px 8px;
                background: rgba(0, 0, 0, 0.75);
                color: #fff;
                border-radius: 6px;
                font-size: 13px;
                pointer-events: none;
            "
        ></div>

        <script type="module">
            import { Parser } from "https://esm.sh/@dxfjs/parser@0.3.2";
            import * as THREE from "https://esm.sh/three@0.160.0";
            import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";

            // UI helpers
            const el = (id) => document.getElementById(id);
            const statusEl = el("status");
            function showStatus(text, timeout = 2500) {
                if (!text) {
                    statusEl.style.display = "none";
                    return;
                }
                statusEl.textContent = text;
                statusEl.style.display = "block";
                if (timeout)
                    setTimeout(() => {
                        statusEl.style.display = "none";
                    }, timeout);
            }
            const toRad = (deg) => (deg * Math.PI) / 180;

            // 2D Viewer (Orthographic)
            const container = el("viewer");
            const state = {
                scene: null,
                camera: null,
                renderer: null,
                controls: null,
                group: null,
                anim: null,
                baseSize: 100, // world units height at zoom=1
            };

            init2D();

            function init2D() {
                if (state.renderer) return;
                const rect = container.getBoundingClientRect();

                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x111111);

                const aspect = Math.max(rect.width / rect.height, 1e-6);
                const halfH = state.baseSize / 2;
                const halfW = (state.baseSize * aspect) / 2;
                state.camera = new THREE.OrthographicCamera(
                    -halfW,
                    halfW,
                    halfH,
                    -halfH,
                    -1e9,
                    1e9,
                );
                state.camera.position.set(0, 0, 100);
                state.camera.up.set(0, 1, 0);
                state.camera.lookAt(0, 0, 0);

                state.renderer = new THREE.WebGLRenderer({ antialias: true });
                state.renderer.setPixelRatio(
                    Math.min(devicePixelRatio || 1, 2),
                );
                state.renderer.setSize(rect.width, rect.height);
                container.appendChild(state.renderer.domElement);

                state.controls = new OrbitControls(
                    state.camera,
                    state.renderer.domElement,
                );
                state.controls.enableRotate = false;
                state.controls.enableDamping = true;
                state.controls.dampingFactor = 0.08;
                state.controls.screenSpacePanning = true;
                state.controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN,
                };
                state.controls.touches = {
                    ONE: THREE.TOUCH.PAN,
                    TWO: THREE.TOUCH.DOLLY_PAN,
                };

                // Background helpers removed for cleaner view

                state.group = new THREE.Group();
                state.scene.add(state.group);
                // overlay group for highlights/measurements (keeps overlays separate)
                state.overlayGroup = new THREE.Group();
                state.scene.add(state.overlayGroup);

                function loop() {
                    state.anim = requestAnimationFrame(loop);
                    state.controls.update();
                    state.renderer.render(state.scene, state.camera);
                }
                loop();

                window.addEventListener("resize", handleResize2D);

                // Drag & drop
                ["dragenter", "dragover", "dragleave", "drop"].forEach((ev) => {
                    container.addEventListener(ev, (e) => e.preventDefault());
                });
                container.addEventListener("drop", async (e) => {
                    const f = e.dataTransfer.files?.[0];
                    if (!f) return;
                    await loadFile(f);
                });
            }

            function handleResize2D() {
                if (!state.renderer) return;
                const rect = container.getBoundingClientRect();
                state.renderer.setSize(rect.width, rect.height);
                const aspect = Math.max(rect.width / rect.height, 1e-6);
                const halfH = state.baseSize / 2;
                const halfW = (state.baseSize * aspect) / 2;
                state.camera.left = -halfW;
                state.camera.right = halfW;
                state.camera.top = halfH;
                state.camera.bottom = -halfH;
                state.camera.updateProjectionMatrix();
            }

            function clear2D() {
                if (!state.group) return;
                while (state.group.children.length) {
                    const c = state.group.children.pop();
                    c.geometry?.dispose?.();
                    c.material?.dispose?.();
                }
            }

            // DXF -> Three helpers
            function aciToHex(n) {
                const map = {
                    1: 0xff0000, // red
                    2: 0xffff00, // yellow
                    3: 0x00ff00, // green
                    4: 0x00ffff, // cyan
                    5: 0x0000ff, // blue
                    6: 0xff00ff, // magenta
                    7: 0xffffff, // white
                    8: 0x808080, // gray
                    9: 0xc0c0c0, // light gray
                };
                if (n in map) return map[n];
                if (n >= 10 && n <= 255) {
                    const hue = ((n - 10) / 245) * 360;
                    return hsvToHex(hue, 0.7, 1.0);
                }
                return 0x00ffff; // default cyan
            }
            function hsvToHex(h, s, v) {
                const c = v * s;
                const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                const m = v - c;
                let r = 0,
                    g = 0,
                    b = 0;
                if (0 <= h && h < 60) [r, g, b] = [c, x, 0];
                else if (60 <= h && h < 120) [r, g, b] = [x, c, 0];
                else if (120 <= h && h < 180) [r, g, b] = [0, c, x];
                else if (180 <= h && h < 240) [r, g, b] = [0, x, c];
                else if (240 <= h && h < 300) [r, g, b] = [x, 0, c];
                else [r, g, b] = [c, 0, x];
                const R = Math.round((r + m) * 255);
                const G = Math.round((g + m) * 255);
                const B = Math.round((b + m) * 255);
                return (R << 16) | (G << 8) | B;
            }
            function colorFromEntity(ent, dxf) {
                // Prefer trueColor (24-bit) if present, then ACI, then layer color, otherwise cyan.
                try {
                    const tc =
                        ent?.trueColor ??
                        ent?.truecolor ??
                        ent?.trueColorValue ??
                        ent?.true_color ??
                        ent?.truecolour ??
                        null;
                    if (typeof tc === "number" && tc !== 0) {
                        // Mask to 24-bit RGB
                        const col = tc & 0xffffff;
                        console.debug(
                            "[DXF COLOR] using trueColor ->",
                            "#" + col.toString(16).padStart(6, "0"),
                            ent,
                        );
                        return col;
                    }
                } catch (e) {
                    // ignore
                }
                const aci =
                    ent?.colorNumber ??
                    ent?.color ??
                    ent?.aci ??
                    ent?.Color ??
                    null;
                if (typeof aci === "number" && aci >= 1 && aci <= 255) {
                    const col = aciToHex(aci);
                    console.debug(
                        "[DXF COLOR] using ACI",
                        aci,
                        "->",
                        "#" + col.toString(16).padStart(6, "0"),
                    );
                    return col;
                }
                // Try layer color from dxf.tables (various shapes)
                try {
                    const layerName =
                        ent?.layer ?? ent?.layerName ?? ent?.Layer;
                    if (dxf && layerName) {
                        // try common table shapes: { layer: { records: [...] } } or tables.layer.records
                        const tbl = dxf.tables ?? dxf?.tables;
                        const candidates =
                            tbl?.layer?.records ??
                            tbl?.LAYER?.records ??
                            tbl?.layers ??
                            tbl?.layer ??
                            null;
                        if (Array.isArray(candidates)) {
                            const rec = candidates.find(
                                (r) =>
                                    r?.name === layerName ||
                                    r?.Name === layerName ||
                                    r?.NAME === layerName,
                            );
                            if (rec) {
                                const lc =
                                    rec?.color ??
                                    rec?.colorNumber ??
                                    rec?.Color ??
                                    null;
                                if (typeof lc === "number") {
                                    console.debug(
                                        "[DXF COLOR] using layer color",
                                        layerName,
                                        lc,
                                    );
                                    return aciToHex(lc);
                                }
                            }
                        } else if (
                            candidates &&
                            typeof candidates === "object"
                        ) {
                            const rec =
                                candidates[layerName] ||
                                candidates.records?.find?.(
                                    (r) =>
                                        r?.name === layerName ||
                                        r?.Name === layerName,
                                );
                            const lc =
                                rec?.color ??
                                rec?.colorNumber ??
                                rec?.Color ??
                                null;
                            if (typeof lc === "number") {
                                console.debug(
                                    "[DXF COLOR] using layer color (obj)",
                                    layerName,
                                    lc,
                                );
                                return aciToHex(lc);
                            }
                        }
                    }
                } catch (e) {
                    // ignore
                }
                return 0x00ffff;
            }

            function addLine2D(a, b, color = 0x00ffff) {
                const pos = new Float32Array([a.x, a.y, 0, b.x, b.y, 0]);
                const geom = new THREE.BufferGeometry();
                geom.setAttribute(
                    "position",
                    new THREE.BufferAttribute(pos, 3),
                );
                const mat = new THREE.LineBasicMaterial({ color });
                const obj = new THREE.LineSegments(geom, mat);
                // store metadata for picking/measurement
                obj.userData = {
                    type: "line",
                    a: { x: a.x, y: a.y },
                    b: { x: b.x, y: b.y },
                    color,
                    length: Math.hypot(b.x - a.x, b.y - a.y),
                };
                state.group.add(obj);
            }

            function addPolyline2D(pts, color = 0x00ffff) {
                if (pts.length < 2) return;
                const pos = new Float32Array((pts.length - 1) * 6);
                let total = 0;
                for (let i = 0; i < pts.length - 1; i++) {
                    const a = pts[i],
                        b = pts[i + 1];
                    pos.set([a.x, a.y, 0, b.x, b.y, 0], i * 6);
                    total += Math.hypot(b.x - a.x, b.y - a.y);
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute(
                    "position",
                    new THREE.BufferAttribute(pos, 3),
                );
                const mat = new THREE.LineBasicMaterial({ color });
                const obj = new THREE.LineSegments(geom, mat);
                // store metadata for picking/measurement (clone points)
                obj.userData = {
                    type: "polyline",
                    pts: pts.map((p) => ({ x: p.x, y: p.y })),
                    color,
                    length: total,
                };
                state.group.add(obj);
            }

            function addArc2D(
                center,
                radius,
                startDeg,
                endDeg,
                color = 0x00ffff,
            ) {
                // Normalize input angles to radians
                const start = toRad(startDeg);
                const end = toRad(endDeg);
                let sweep = end - start;

                // Normalize sweep to the shortest equivalent angle in (-PI, PI]
                const TWO_PI = Math.PI * 2;
                // Bring into (-2PI, 2PI) first (safe for large inputs)
                if (sweep > TWO_PI || sweep < -TWO_PI) {
                    sweep = ((sweep % TWO_PI) + TWO_PI) % TWO_PI;
                    if (sweep > Math.PI) sweep -= TWO_PI;
                }
                // Now ensure within (-PI, PI]
                while (sweep <= -Math.PI) sweep += TWO_PI;
                while (sweep > Math.PI) sweep -= TWO_PI;

                // If sweep is effectively zero, keep geometry minimal but still selectable as an arc
                if (Math.abs(sweep) < 1e-12) {
                    sweep = 0;
                }

                const absSweep = Math.abs(sweep);
                const segs = Math.max(
                    32,
                    Math.ceil((Math.max(Math.abs(radius), 1) * absSweep) / 2),
                );

                // Build geometry for rendering (as line segments), but keep userData as "arc" for picking/measurement
                const pos = new Float32Array(segs * 6);
                for (let i = 0; i < segs; i++) {
                    const t1 = i / segs;
                    const t2 = (i + 1) / segs;
                    const ang1 = start + t1 * sweep;
                    const ang2 = start + t2 * sweep;
                    const x1 = center.x + radius * Math.cos(ang1);
                    const y1 = center.y + radius * Math.sin(ang1);
                    const x2 = center.x + radius * Math.cos(ang2);
                    const y2 = center.y + radius * Math.sin(ang2);
                    pos.set([x1, y1, 0, x2, y2, 0], i * 6);
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute(
                    "position",
                    new THREE.BufferAttribute(pos, 3),
                );
                const mat = new THREE.LineBasicMaterial({ color });
                const obj = new THREE.LineSegments(geom, mat);

                // Store normalized metadata: ensure startDeg/endDeg reflect the actual sweep used
                const startRad = start;
                const endRad = start + sweep;
                const startDegNorm = (startRad * 180) / Math.PI;
                const endDegNorm = (endRad * 180) / Math.PI;

                obj.userData = {
                    type: "arc",
                    center: { x: center.x, y: center.y },
                    radius,
                    startDeg: startDegNorm,
                    endDeg: endDegNorm,
                    startRad,
                    endRad,
                    sweep,
                    color,
                    length: Math.abs(radius * sweep),
                };
                state.group.add(obj);
            }

            function addCircle2D(center, radius, color = 0x00ffff) {
                const segs = Math.max(64, Math.ceil(radius * 8));
                const pos = new Float32Array(segs * 6);
                for (let i = 0; i < segs; i++) {
                    const t1 = (i / segs) * 2 * Math.PI;
                    const t2 = ((i + 1) / segs) * 2 * Math.PI;
                    const x1 = center.x + radius * Math.cos(t1);
                    const y1 = center.y + radius * Math.sin(t1);
                    const x2 = center.x + radius * Math.cos(t2);
                    const y2 = center.y + radius * Math.sin(t2);
                    pos.set([x1, y1, 0, x2, y2, 0], i * 6);
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute(
                    "position",
                    new THREE.BufferAttribute(pos, 3),
                );
                const mat = new THREE.LineBasicMaterial({ color });
                const obj = new THREE.LineSegments(geom, mat);
                obj.userData = {
                    type: "circle",
                    center: { x: center.x, y: center.y },
                    radius,
                    color,
                    length: 2 * Math.PI * radius,
                };
                state.group.add(obj);
            }

            function addPoint2D(pt, color = 0xffaa00, size = 1) {
                const s = size;
                addLine2D(
                    { x: pt.x - s, y: pt.y },
                    { x: pt.x + s, y: pt.y },
                    color,
                );
                addLine2D(
                    { x: pt.x, y: pt.y - s },
                    { x: pt.x, y: pt.y + s },
                    color,
                );
            }

            // Create a sprite from text using a canvas so text appears in the 2D scene.
            function createTextSprite(text, options = {}) {
                const {
                    font = "Arial",
                    height = 1,
                    color = 0xffffff,
                    background = null,
                    padding = 4,
                } = options;

                // Create canvas
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");
                if (!ctx) return null;

                // Choose a base font size in px that maps approx to model units.
                // We'll scale the sprite later using height.
                const basePx = 48; // large for quality
                ctx.font = `${basePx}px ${font}`;
                // measure
                const metrics = ctx.measureText(text || "");
                const textWidth = Math.ceil(metrics.width);
                const textHeight = basePx;

                canvas.width = textWidth + padding * 2;
                canvas.height = textHeight + padding * 2;

                // redraw after resize
                ctx.font = `${basePx}px ${font}`;
                if (background) {
                    ctx.fillStyle = background;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                // fill text
                ctx.fillStyle =
                    "#" + (color >>> 0).toString(16).padStart(6, "0");
                ctx.textBaseline = "top";
                ctx.fillText(text, padding, padding);

                // Create texture
                const tex = new THREE.CanvasTexture(canvas);
                tex.minFilter = THREE.LinearFilter;
                tex.needsUpdate = true;

                const mat = new THREE.SpriteMaterial({
                    map: tex,
                    depthTest: false,
                });
                const sprite = new THREE.Sprite(mat);
                // Scale sprite so that its height in world units equals `height`
                // The canvas height in px corresponds to basePx px -> map to world units.
                // Use scale factor: height (world units) * (canvas.height / basePx)
                const scaleFactor = (height / basePx) * canvas.height;
                sprite.scale.set(
                    (canvas.width / canvas.height) * scaleFactor,
                    scaleFactor,
                    1,
                );

                // store original text for debugging
                sprite.userData = { text, options, canvas };
                return sprite;
            }

            function addText2D(
                pos,
                text,
                color = 0xffffff,
                height = 1,
                rotationDeg = 0,
            ) {
                if (!state.group) return;
                const sprite = createTextSprite(String(text), {
                    font: "Arial",
                    height,
                    color,
                    background: null,
                });
                if (!sprite) return;
                sprite.position.set(pos.x, pos.y, 0);
                // rotate sprite in plane (clockwise deg -> rad)
                sprite.material.rotation = (-rotationDeg * Math.PI) / 180;
                state.group.add(sprite);
            }

            function render2DFromDXF(dxf) {
                clear2D();
                // Support both legacy flat entity lists and @dxfjs/parser shaped output.
                // @dxfjs/parser returns `dxf.entities` as an object with arrays:
                //   { lines: [...], lwPolylines: [...], polylines: [...], arcs: [...], circles: [...], points: [...], texts: [...] }
                // But some DXF sources or other parsers may produce an array of entity objects.
                const entsObj = dxf?.entities ?? {};
                const collect = (key) => {
                    const v = entsObj[key];
                    return Array.isArray(v) ? v : [];
                };

                // If user provided a flat array (older formats), use it too.
                let flatEntities = [];
                if (Array.isArray(dxf?.entities)) flatEntities = dxf.entities;

                // Debug: log counts coming from parser-shaped output and flat fallback
                try {
                    const counts = {
                        lines: collect("lines").length,
                        lwPolylines: collect("lwPolylines").length,
                        polylines: collect("polylines").length,
                        arcs: collect("arcs").length,
                        circles: collect("circles").length,
                        points: collect("points").length,
                        texts: collect("texts").length,
                        flatEntities: flatEntities.length,
                    };
                    console.log("[DXF DEBUG] entity counts:", counts);
                } catch (err) {
                    console.warn("[DXF DEBUG] failed to compute counts", err);
                }

                // 1) Handle parser-specific arrays first
                // Lines (Parser: startX, startY, endX, endY)
                for (const l of collect("lines")) {
                    const sx = l.startX ?? l.startx ?? l["startX"];
                    const sy = l.startY ?? l.starty ?? l["startY"];
                    const ex = l.endX ?? l.endx ?? l["endX"];
                    const ey = l.endY ?? l.endy ?? l["endY"];
                    const color = colorFromEntity(l, dxf);
                    if (sx != null && sy != null && ex != null && ey != null) {
                        addLine2D({ x: sx, y: sy }, { x: ex, y: ey }, color);
                    }
                }

                // LWPOLYLINEs
                for (const lw of collect("lwPolylines")) {
                    const verts = lw.vertices || lw.points || lw.vertices || [];
                    const pts = verts.filter(Boolean).map((v) => ({
                        x: v.x ?? v[0] ?? 0,
                        y: v.y ?? v[1] ?? 0,
                    }));
                    if (pts.length >= 2) {
                        const closed =
                            !!lw.closed ||
                            !!lw.shape ||
                            !!lw.isClosed ||
                            (!!lw.flag && (lw.flag & 1) === 1);
                        if (closed) pts.push(pts[0]);
                        addPolyline2D(pts, colorFromEntity(lw, dxf));
                    }
                }

                // POLYLINEs (Parser: polylines[].vertices)
                for (const pl of collect("polylines")) {
                    const verts = pl.vertices || [];
                    const pts = verts
                        .filter(Boolean)
                        .map((v) => ({ x: v.x ?? 0, y: v.y ?? 0 }));
                    if (pts.length >= 2) {
                        const closed =
                            !!pl.closed ||
                            !!pl.shape ||
                            !!pl.isClosed ||
                            (!!pl.flag && (pl.flag & 1) === 1);
                        if (closed) pts.push(pts[0]);
                        addPolyline2D(pts, colorFromEntity(pl, dxf));
                    }
                }

                // ARCs (Parser: centerX, centerY, radius, startAngle, endAngle)
                for (const a of collect("arcs")) {
                    const cx = a.centerX ?? a.centerx ?? a["centerX"];
                    const cy = a.centerY ?? a.centery ?? a["centerY"];
                    const r = a.radius ?? a["radius"] ?? a.r;
                    const sa = a.startAngle ?? a.startAngle ?? a.start ?? 0;
                    const ea = a.endAngle ?? a.endAngle ?? a.end ?? 0;
                    if (cx != null && cy != null && r != null) {
                        addArc2D(
                            { x: cx, y: cy },
                            r,
                            sa,
                            ea,
                            colorFromEntity(a, dxf),
                        );
                    }
                }

                // CIRCLEs (Parser: centerX, centerY, radius)
                for (const c of collect("circles")) {
                    const cx = c.centerX ?? c.centerx ?? c["centerX"];
                    const cy = c.centerY ?? c.centery ?? c["centerY"];
                    const r = c.radius ?? c["radius"] ?? c.r;
                    if (cx != null && cy != null && r != null) {
                        addCircle2D(
                            { x: cx, y: cy },
                            r,
                            colorFromEntity(c, dxf),
                        );
                    }
                }

                // POINTs (Parser: x, y)
                for (const p of collect("points")) {
                    const x = p.x ?? p.x0 ?? p["x"];
                    const y = p.y ?? p.y0 ?? p["y"];
                    if (x != null && y != null)
                        addPoint2D({ x, y }, colorFromEntity(p, dxf), 1);
                }

                // TEXTs from parser-shaped output (Parser: texts[] with properties like text, x/y or firstAlignmentX/firstAlignmentY)
                for (const t of collect("texts")) {
                    // Parser's Text spec may store alignment as firstAlignmentX/Y or as x/y
                    const px =
                        t.firstAlignmentX ??
                        t.firstAlignmentPointX ??
                        t.x ??
                        t.x0 ??
                        t.x1 ??
                        (t.position && t.position.x) ??
                        null;
                    const py =
                        t.firstAlignmentY ??
                        t.firstAlignmentPointY ??
                        t.y ??
                        t.y0 ??
                        t.y1 ??
                        (t.position && t.position.y) ??
                        null;
                    const content =
                        t.text ??
                        t.value ??
                        t.string ??
                        t.contents ??
                        t.textString ??
                        t.Text ??
                        "";
                    // text height
                    const height =
                        t.textHeight ??
                        t.textHeight ??
                        t.height ??
                        t.dxfHeight ??
                        1;
                    const rot = t.rotation ?? t.obliqueAngle ?? 0;
                    if (px != null && py != null && content) {
                        addText2D(
                            { x: px, y: py },
                            content,
                            colorFromEntity(t, dxf),
                            height,
                            rot,
                        );
                    }
                }

                // 2) Fallback: handle flat entity arrays or other shapes (including TEXT)
                for (const ent of flatEntities) {
                    const type = String(
                        ent?.type || ent?.Type || "",
                    ).toUpperCase();
                    const color = colorFromEntity(ent, dxf);

                    if (type === "LINE") {
                        // older shape: ent.start.x / ent.end.x
                        const sx =
                            ent.start?.x ??
                            ent.startX ??
                            ent.startx ??
                            ent.x1 ??
                            null;
                        const sy =
                            ent.start?.y ??
                            ent.startY ??
                            ent.starty ??
                            ent.y1 ??
                            null;
                        const ex =
                            ent.end?.x ??
                            ent.endX ??
                            ent.endx ??
                            ent.x2 ??
                            null;
                        const ey =
                            ent.end?.y ??
                            ent.endY ??
                            ent.endy ??
                            ent.y2 ??
                            null;
                        if (
                            sx != null &&
                            sy != null &&
                            ex != null &&
                            ey != null
                        ) {
                            addLine2D(
                                { x: sx, y: sy },
                                { x: ex, y: ey },
                                color,
                            );
                        }
                    } else if (type === "LWPOLYLINE" || type === "POLYLINE") {
                        const verts = ent.vertices || ent.points || [];
                        const pts = verts
                            .filter(Boolean)
                            .map((v) => ({ x: v.x ?? 0, y: v.y ?? 0 }));
                        if (pts.length >= 2) {
                            const closed =
                                !!ent.closed || !!ent.shape || !!ent.isClosed;
                            if (closed) pts.push(pts[0]);
                            addPolyline2D(pts, color);
                        }
                    } else if (type === "ARC") {
                        const center = ent.center || {
                            x: ent.centerX,
                            y: ent.centerY,
                        };
                        const r = ent.radius ?? ent.R ?? null;
                        const sa = ent.startAngle ?? ent.start ?? 0;
                        const ea = ent.endAngle ?? ent.end ?? 0;
                        if (
                            center &&
                            center.x != null &&
                            center.y != null &&
                            r != null
                        ) {
                            addArc2D(center, r, sa, ea, color);
                        }
                    } else if (type === "CIRCLE") {
                        const center = ent.center || {
                            x: ent.centerX,
                            y: ent.centerY,
                        };
                        const r = ent.radius ?? ent.R ?? null;
                        if (
                            center &&
                            center.x != null &&
                            center.y != null &&
                            r != null
                        ) {
                            addCircle2D(center, r, color);
                        }
                    } else if (type === "POINT") {
                        const pos = ent.position || ent;
                        if (pos && pos.x != null && pos.y != null)
                            addPoint2D({ x: pos.x, y: pos.y }, color, 1);
                    } else if (type === "TEXT") {
                        // handle older flat TEXT entities
                        const px =
                            ent.firstAlignmentX ??
                            ent.firstAlignmentPointX ??
                            ent.x ??
                            ent.position?.x ??
                            (ent.start && ent.start.x) ??
                            null;
                        const py =
                            ent.firstAlignmentY ??
                            ent.firstAlignmentPointY ??
                            ent.y ??
                            ent.position?.y ??
                            (ent.start && ent.start.y) ??
                            null;
                        const content =
                            ent.text ??
                            ent.value ??
                            ent.string ??
                            ent.contents ??
                            ent.Text ??
                            "";
                        const height = ent.textHeight ?? ent.height ?? 1;
                        const rot = ent.rotation ?? ent.obliqueAngle ?? 0;
                        if (px != null && py != null && content) {
                            addText2D(
                                { x: px, y: py },
                                content,
                                color,
                                height,
                                rot,
                            );
                        }
                    }
                    // Extend as needed: ELLIPSE, SPLINE, INSERT, etc.
                }

                // Debug: report bounding box of drawn group
                try {
                    const box = new THREE.Box3().setFromObject(state.group);
                    console.log("[DXF DEBUG] group bbox:", {
                        min: box.min
                            ? { x: box.min.x, y: box.min.y, z: box.min.z }
                            : null,
                        max: box.max
                            ? { x: box.max.x, y: box.max.y, z: box.max.z }
                            : null,
                    });
                } catch (err) {
                    console.warn("[DXF DEBUG] bbox failed", err);
                }
                fit2D(0.05);
            }

            function fit2D(padding = 0.05) {
                if (!state.group) return;
                const box = new THREE.Box3().setFromObject(state.group);
                if (
                    !isFinite(box.min.x) ||
                    !isFinite(box.max.x) ||
                    box.min.equals(box.max)
                )
                    return;

                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                const rect = container.getBoundingClientRect();
                const aspect = Math.max(rect.width / rect.height, 1e-6);

                let width = Math.max(size.x, 1e-6);
                let height = Math.max(size.y, 1e-6);
                width *= 1 + padding * 2;
                height *= 1 + padding * 2;

                let viewH = height;
                if (viewH * aspect < width) {
                    viewH = width / aspect;
                }

                state.baseSize = viewH;
                handleResize2D();

                state.controls.target.set(center.x, center.y, 0);
                state.camera.position.set(center.x, center.y, 100);
                state.camera.zoom = 1;
                state.camera.updateProjectionMatrix();
                state.controls.update();
            }

            // Parsing and loading
            async function parseDXFText(text) {
                const parser = new Parser();
                const parsed = await parser.parse(text);
                // Expose parsed DXF and original text to the window for runtime inspection
                try {
                    window.__lastParsedDXF = parsed;
                    window.__lastDXFText = text;
                    console.debug(
                        "[DXF DEBUG] parsed object available as window.__lastParsedDXF",
                    );
                } catch (e) {
                    // ignore in environments that restrict window
                }
                return parsed;
            }

            async function loadUrl(url) {
                let absUrl;
                try {
                    absUrl = new URL(url, window.location.href).href;
                } catch {
                    absUrl = url;
                }
                showStatus("A carregar: " + absUrl);
                try {
                    const res = await fetch(absUrl);
                    const text = await res.text();
                    const dxf = await parseDXFText(text);
                    render2DFromDXF(dxf);
                    showStatus("Carregado", 1200);
                } catch (e) {
                    console.error(e);
                    showStatus("Erro a carregar DXF", 4000);
                }
            }

            async function loadFile(file) {
                try {
                    showStatus("A ler ficheiro...");
                    const text = await file.text();
                    const dxf = await parseDXFText(text);
                    console.debug(
                        "[DXF DEBUG] about to render parsed DXF; entities/tables summary:",
                        {
                            entities: dxf?.entities,
                            tables: dxf?.tables,
                        },
                    );
                    render2DFromDXF(dxf);
                    // Ensure parsed data and raw text accessible from window for debugging
                    try {
                        window.__lastParsedDXF = dxf;
                        window.__lastDXFText = text;
                    } catch (e) {
                        // ignore
                    }
                    showStatus("Ficheiro carregado", 1200);
                } catch (e) {
                    console.error(e);
                    showStatus("Erro a ler ficheiro", 4000);
                }
            }

            // UI wiring
            el("file").addEventListener("change", async (e) => {
                const f = e.target.files?.[0];
                if (!f) return;
                await loadFile(f);
            });
            el("fit").addEventListener("click", () => fit2D(0.05));

            // Measurement UI and picking (pointer-based, toggle on repeated clicks, mobile-friendly)
            (function setupPicking() {
                const measurementEl = document.getElementById("measurement");
                let selected = null;
                let highlight = null;
                let pointerDownInfo = null;

                function clearHighlight() {
                    if (highlight) {
                        highlight.geometry?.dispose?.();
                        highlight.material?.dispose?.();
                        if (
                            state.overlayGroup &&
                            state.overlayGroup.children.includes(highlight)
                        )
                            state.overlayGroup.remove(highlight);
                        highlight = null;
                    }
                }

                function hideMeasurement() {
                    if (measurementEl) measurementEl.style.display = "none";
                }

                function showMeasurementAtClient(msg, clientX, clientY) {
                    if (!measurementEl) return;
                    measurementEl.textContent = msg;
                    measurementEl.style.left = clientX + 12 + "px";
                    measurementEl.style.top = clientY + 12 + "px";
                    measurementEl.style.display = "block";
                }

                // Convert a client pointer event to world coordinates on the z=0 plane.
                // This replicates the original worldFromMouseEvent logic directly so we don't
                // rely on a removed helper.
                function toWorld(e) {
                    if (!state.camera || !state.renderer) {
                        console.error(
                            "[toWorld] Camera or renderer not initialized",
                        );
                        return { x: 0, y: 0, z: 0 };
                    }

                    const rect =
                        state.renderer.domElement.getBoundingClientRect();
                    const ndcX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const ndcY =
                        -((e.clientY - rect.top) / rect.height) * 2 + 1;

                    console.log(
                        "[toWorld] Client:",
                        e.clientX,
                        e.clientY,
                        "NDC:",
                        ndcX,
                        ndcY,
                    );

                    // For orthographic camera, we need to account for zoom and pan
                    // The camera bounds are scaled by zoom and offset by target position
                    const cam = state.camera;
                    const zoom = cam.zoom || 1;

                    // Get the actual viewport dimensions in world units after zoom
                    const viewWidth = (cam.right - cam.left) / zoom;
                    const viewHeight = (cam.top - cam.bottom) / zoom;

                    // Get camera target (where the camera is looking at - affected by pan)
                    const target = state.controls
                        ? state.controls.target
                        : new THREE.Vector3(0, 0, 0);

                    // Calculate world position
                    // NDC ranges from -1 to 1, convert to 0 to 1 range
                    const worldX = target.x + (ndcX * viewWidth) / 2;
                    const worldY = target.y + (ndcY * viewHeight) / 2;

                    console.log(
                        "[toWorld] World:",
                        worldX,
                        worldY,
                        "Zoom:",
                        zoom,
                        "Target:",
                        { x: target.x, y: target.y },
                        "ViewSize:",
                        { w: viewWidth, h: viewHeight },
                    );

                    return { x: worldX, y: worldY, z: 0 };
                }

                // Make toWorld accessible globally for measure tool
                state.toWorld = toWorld;

                // Shared nearest-finder function for both clicking and hovering
                function findNearestLocal(worldPt, maxDistance) {
                    let best = null;
                    let bestDist = Infinity;
                    let bestPriority = Infinity;
                    const tieEps = Math.max(1e-9, maxDistance * 0.25);
                    const getPriority = (kind) =>
                        kind === "circle" || kind === "arc" ? 0 : 1;
                    const px = worldPt.x,
                        py = worldPt.y;

                    const distPointToSegment = (px, py, ax, ay, bx, by) => {
                        const vx = bx - ax,
                            vy = by - ay;
                        const wx = px - ax,
                            wy = py - ay;
                        const c1 = vx * wx + vy * wy;
                        if (c1 <= 0) return Math.hypot(px - ax, py - ay);
                        const c2 = vx * vx + vy * vy;
                        if (c2 <= c1) return Math.hypot(px - bx, py - by);
                        const t = c1 / c2;
                        const projx = ax + t * vx,
                            projy = ay + t * vy;
                        return Math.hypot(px - projx, py - projy);
                    };

                    const normalizeAngle = (a) => {
                        let x = a % (Math.PI * 2);
                        if (x < 0) x += Math.PI * 2;
                        return x;
                    };

                    const distPointToArc = (
                        px,
                        py,
                        cx,
                        cy,
                        r,
                        startRad,
                        sweep,
                    ) => {
                        // Degenerate: treat as circle if no sweep
                        if (Math.abs(sweep) < 1e-12) {
                            const dcenter = Math.hypot(px - cx, py - cy);
                            return Math.abs(dcenter - r);
                        }
                        const ang = Math.atan2(py - cy, px - cx);
                        const rel = normalizeAngle(ang - startRad);
                        const span = Math.abs(sweep);
                        const dir = sweep >= 0 ? 1 : -1;
                        const clampedRel = Math.min(Math.max(rel, 0), span);
                        const t =
                            startRad + (dir >= 0 ? clampedRel : -clampedRel);
                        const ax = cx + r * Math.cos(t);
                        const ay = cy + r * Math.sin(t);
                        return Math.hypot(px - ax, py - ay);
                    };

                    let checkedCount = 0;
                    let skippedCount = 0;

                    for (const child of state.group.children) {
                        const ud = child.userData || {};
                        if (!ud.type) {
                            skippedCount++;
                            continue;
                        }
                        checkedCount++;

                        if (ud.type === "circle") {
                            const dcenter = Math.hypot(
                                px - ud.center.x,
                                py - ud.center.y,
                            );
                            const dr = Math.abs(dcenter - ud.radius);
                            if (
                                dr < bestDist - 1e-9 ||
                                (Math.abs(dr - bestDist) <= tieEps &&
                                    getPriority("circle") < bestPriority)
                            ) {
                                bestDist = dr;
                                bestPriority = getPriority("circle");
                                best = {
                                    kind: "circle",
                                    obj: child,
                                    meta: ud,
                                    dist: dr,
                                };
                            }
                        } else if (ud.type === "arc") {
                            const d = distPointToArc(
                                px,
                                py,
                                ud.center.x,
                                ud.center.y,
                                ud.radius,
                                ud.startRad ?? toRad(ud.startDeg ?? 0),
                                ud.sweep ??
                                    toRad(ud.endDeg ?? 0) -
                                        toRad(ud.startDeg ?? 0),
                            );
                            if (
                                d < bestDist - 1e-9 ||
                                (Math.abs(d - bestDist) <= tieEps &&
                                    getPriority("arc") < bestPriority)
                            ) {
                                bestDist = d;
                                bestPriority = getPriority("arc");
                                best = {
                                    kind: "arc",
                                    obj: child,
                                    meta: ud,
                                    dist: d,
                                };
                            }
                        } else if (ud.type === "line") {
                            const d = distPointToSegment(
                                px,
                                py,
                                ud.a.x,
                                ud.a.y,
                                ud.b.x,
                                ud.b.y,
                            );
                            if (
                                d < bestDist - 1e-9 ||
                                (Math.abs(d - bestDist) <= tieEps &&
                                    getPriority("line") < bestPriority)
                            ) {
                                bestDist = d;
                                bestPriority = getPriority("line");
                                best = {
                                    kind: "line",
                                    obj: child,
                                    meta: ud,
                                    segment: { a: ud.a, b: ud.b },
                                    dist: d,
                                };
                            }
                        } else if (ud.type === "polyline") {
                            for (
                                let i = 0;
                                i < (ud.pts || []).length - 1;
                                i++
                            ) {
                                const a = ud.pts[i],
                                    b = ud.pts[i + 1];
                                const d = distPointToSegment(
                                    px,
                                    py,
                                    a.x,
                                    a.y,
                                    b.x,
                                    b.y,
                                );
                                if (
                                    d < bestDist - 1e-9 ||
                                    (Math.abs(d - bestDist) <= tieEps &&
                                        getPriority("polyline") < bestPriority)
                                ) {
                                    bestDist = d;
                                    bestPriority = getPriority("polyline");
                                    best = {
                                        kind: "polyline",
                                        obj: child,
                                        meta: ud,
                                        segment: { a, b },
                                        dist: d,
                                        totalLength: ud.length,
                                    };
                                }
                            }
                        }
                    }

                    if (bestDist <= maxDistance) return best;
                    return null;
                }

                function makeHighlightLine(ax, ay, bx, by, color = 0xff00ff) {
                    console.log("[HIGHLIGHT] Line:", { ax, ay, bx, by });
                    clearHighlight();
                    const pos = new Float32Array([ax, ay, 0, bx, by, 0]);
                    const geom = new THREE.BufferGeometry();
                    geom.setAttribute(
                        "position",
                        new THREE.BufferAttribute(pos, 3),
                    );
                    // Use a distinctive highlight appearance and render on top
                    const mat = new THREE.LineBasicMaterial({
                        color,
                        toneMapped: false,
                        depthTest: false,
                        transparent: true,
                        opacity: 0.95,
                        linewidth: 4,
                    });
                    highlight = new THREE.LineSegments(geom, mat);
                    highlight.renderOrder = 9999;
                    // ensure highlight renders above small z-fighting by nudging slightly in z
                    highlight.position.z = 0.001;
                    if (state.overlayGroup) state.overlayGroup.add(highlight);
                    else state.group.add(highlight);
                    if (highlight.material)
                        highlight.material.depthWrite = false;
                }

                function makeHighlightPolyline(pts, color = 0xff00ff) {
                    clearHighlight();
                    if (!pts || pts.length < 2) return;
                    const segs = pts.length - 1;
                    const pos = new Float32Array(segs * 6);
                    for (let i = 0; i < segs; i++) {
                        const a = pts[i],
                            b = pts[i + 1];
                        pos.set([a.x, a.y, 0, b.x, b.y, 0], i * 6);
                    }
                    const geom = new THREE.BufferGeometry();
                    geom.setAttribute(
                        "position",
                        new THREE.BufferAttribute(pos, 3),
                    );
                    const mat = new THREE.LineBasicMaterial({
                        color,
                        toneMapped: false,
                        depthTest: false,
                        transparent: true,
                        opacity: 0.95,
                        linewidth: 4,
                    });
                    highlight = new THREE.LineSegments(geom, mat);
                    highlight.renderOrder = 9999;
                    highlight.position.z = 0.001;
                    if (state.overlayGroup) state.overlayGroup.add(highlight);
                    else state.group.add(highlight);
                    if (highlight.material)
                        highlight.material.depthWrite = false;
                }

                function makeHighlightCircle(center, radius, color = 0xff00ff) {
                    clearHighlight();
                    const segs = 96;
                    const pos = new Float32Array(segs * 6);
                    for (let i = 0; i < segs; i++) {
                        const aang = (i / segs) * Math.PI * 2;
                        const bang = ((i + 1) / segs) * Math.PI * 2;
                        const ax = center.x + Math.cos(aang) * radius;
                        const ay = center.y + Math.sin(aang) * radius;
                        const bx = center.x + Math.cos(bang) * radius;
                        const by = center.y + Math.sin(bang) * radius;
                        pos.set([ax, ay, 0, bx, by, 0], i * 6);
                    }
                    const geom = new THREE.BufferGeometry();
                    geom.setAttribute(
                        "position",
                        new THREE.BufferAttribute(pos, 3),
                    );
                    const mat = new THREE.LineBasicMaterial({
                        color,
                        toneMapped: false,
                        depthTest: false,
                        transparent: true,
                        opacity: 0.95,
                        linewidth: 4,
                    });
                    highlight = new THREE.LineSegments(geom, mat);
                    highlight.renderOrder = 9999;
                    highlight.position.z = 0.001;
                    if (state.overlayGroup) state.overlayGroup.add(highlight);
                    else state.group.add(highlight);
                    if (highlight.material)
                        highlight.material.depthWrite = false;
                }

                function makeHighlightArc(
                    center,
                    radius,
                    startRad,
                    sweep,
                    color = 0xff00ff,
                ) {
                    clearHighlight();
                    const absSweep = Math.abs(sweep);
                    const segs = Math.max(
                        32,
                        Math.ceil((Math.max(radius, 1) * absSweep) / 2),
                    );
                    const pos = new Float32Array(segs * 6);
                    for (let i = 0; i < segs; i++) {
                        const t1 = i / segs;
                        const t2 = (i + 1) / segs;
                        const a1 = startRad + t1 * sweep;
                        const a2 = startRad + t2 * sweep;
                        const x1 = center.x + radius * Math.cos(a1);
                        const y1 = center.y + radius * Math.sin(a1);
                        const x2 = center.x + radius * Math.cos(a2);
                        const y2 = center.y + radius * Math.sin(a2);
                        pos.set([x1, y1, 0, x2, y2, 0], i * 6);
                    }
                    const geom = new THREE.BufferGeometry();
                    geom.setAttribute(
                        "position",
                        new THREE.BufferAttribute(pos, 3),
                    );
                    const mat = new THREE.LineBasicMaterial({
                        color,
                        toneMapped: false,
                        depthTest: false,
                        transparent: true,
                        opacity: 0.95,
                        linewidth: 4,
                    });
                    highlight = new THREE.LineSegments(geom, mat);
                    highlight.renderOrder = 9999;
                    highlight.position.z = 0.001;
                    if (state.overlayGroup) state.overlayGroup.add(highlight);
                    else state.group.add(highlight);
                    if (highlight.material)
                        highlight.material.depthWrite = false;
                }

                // Toggle selection: if clicking same entity, clear; otherwise select new
                function handleSelection(nearest, clientX, clientY) {
                    if (!nearest) {
                        // clicked empty space -> clear
                        selected = null;
                        clearHighlight();
                        hideMeasurement();
                        return;
                    }

                    const kind = nearest.kind;
                    if (
                        selected &&
                        selected.obj === nearest.obj &&
                        selected.kind === kind &&
                        selected.segment?.a?.x === nearest.segment?.a?.x &&
                        selected.segment?.b?.x === nearest.segment?.b?.x
                    ) {
                        // same object + segment clicked again -> toggle off
                        selected = null;
                        clearHighlight();
                        hideMeasurement();
                        return;
                    }

                    // select new
                    selected = nearest;
                    if (kind === "line") {
                        const len = nearest.meta.length;
                        makeHighlightLine(
                            nearest.segment.a.x,
                            nearest.segment.a.y,
                            nearest.segment.b.x,
                            nearest.segment.b.y,
                            0xff0000,
                        );
                        showMeasurementAtClient(
                            "Length: " + len.toFixed(4),
                            clientX,
                            clientY,
                        );
                    } else if (kind === "polyline") {
                        makeHighlightLine(
                            nearest.segment.a.x,
                            nearest.segment.a.y,
                            nearest.segment.b.x,
                            nearest.segment.b.y,
                            0xff0000,
                        );
                        showMeasurementAtClient(
                            "Segment: " +
                                Math.hypot(
                                    nearest.segment.b.x - nearest.segment.a.x,
                                    nearest.segment.b.y - nearest.segment.a.y,
                                ).toFixed(4) +
                                " • Total: " +
                                (nearest.totalLength || 0).toFixed(4),
                            clientX,
                            clientY,
                        );
                    } else if (kind === "arc") {
                        const m = nearest.meta;
                        makeHighlightArc(
                            m.center,
                            m.radius,
                            m.startRad ?? toRad(m.startDeg ?? 0),
                            m.sweep ??
                                toRad(m.endDeg ?? 0) - toRad(m.startDeg ?? 0),
                            0xff0000,
                        );
                        const angleDeg =
                            (Math.abs(
                                m.sweep ??
                                    toRad(m.endDeg ?? 0) -
                                        toRad(m.startDeg ?? 0),
                            ) *
                                180) /
                            Math.PI;
                        showMeasurementAtClient(
                            "Length: " +
                                (
                                    m.length ??
                                    Math.abs(m.radius * (m.sweep ?? 0))
                                ).toFixed(4) +
                                " • Radius R: " +
                                m.radius.toFixed(4) +
                                " • Angle: " +
                                angleDeg.toFixed(2) +
                                "°",
                            clientX,
                            clientY,
                        );
                    } else if (kind === "circle") {
                        const r = nearest.meta.radius;
                        makeHighlightCircle(nearest.meta.center, r, 0xff0000);
                        showMeasurementAtClient(
                            "Length: " +
                                (2 * Math.PI * r).toFixed(4) +
                                " • Radius R: " +
                                r.toFixed(4),
                            clientX,
                            clientY,
                        );
                    }
                }

                // pointer/touch behavior: detect small movement vs drag
                function onPointerDown(e) {
                    pointerDownInfo = {
                        id: e.pointerId,
                        x: e.clientX,
                        y: e.clientY,
                        time: Date.now(),
                    };
                }

                function onPointerUp(e) {
                    // Skip if measure mode is active
                    if (state.measureMode) return;

                    if (!pointerDownInfo) return;
                    // ensure same pointer
                    if (
                        pointerDownInfo.id != null &&
                        e.pointerId !== pointerDownInfo.id
                    ) {
                        pointerDownInfo = null;
                        return;
                    }
                    const dx = e.clientX - pointerDownInfo.x;
                    const dy = e.clientY - pointerDownInfo.y;
                    const movedSq = dx * dx + dy * dy;
                    pointerDownInfo = null;
                    // treat as tap/click if movement small
                    if (movedSq > 8 * 8) {
                        // was a drag, ignore
                        return;
                    }

                    try {
                        const world = toWorld(e);
                        console.log("[PICK] Click at world:", world);
                        // threshold in world units (scale with view)
                        // Reduced from ~10px to ~6px to avoid overly-far picks
                        const h = state.renderer.domElement.height || 1;
                        const worldPerPixel =
                            (state.camera.top - state.camera.bottom) / h;
                        const threshold = Math.max(1e-6, 6 * worldPerPixel); // ~6px (was 10px)
                        console.log(
                            "[PICK] Threshold:",
                            threshold,
                            "Children count:",
                            state.group.children.length,
                        );

                        // Debug: show first 3 children userData
                        console.log("[PICK DEBUG] First 3 children userData:");
                        for (
                            let i = 0;
                            i < Math.min(3, state.group.children.length);
                            i++
                        ) {
                            console.log(
                                "  Child",
                                i,
                                ":",
                                state.group.children[i].userData,
                            );
                        }

                        // use existing nearest finder if present; fallback to scanning children
                        // Local nearest-finder (scans current geometry). Avoids relying on an external function.
                        const nearest = findNearestLocal(world, threshold);
                        console.log("[PICK] Nearest result:", nearest);
                        handleSelection(nearest, e.clientX, e.clientY);
                    } catch (err) {
                        console.error("pointer selection failed", err);
                    }
                }

                // Clear on outside click (double tap area) — pointerdown on background handled above
                state.renderer.domElement.addEventListener(
                    "pointerdown",
                    onPointerDown,
                    { passive: true },
                );
                state.renderer.domElement.addEventListener(
                    "pointerup",
                    onPointerUp,
                    { passive: true },
                );

                // Auto-highlight on hover and hide tooltip when dragging
                let hoverTimeout = null;
                state.renderer.domElement.addEventListener(
                    "pointermove",
                    (e) => {
                        // When dragging, hide the measurement tooltip for clarity
                        if (pointerDownInfo) {
                            const dx = e.clientX - pointerDownInfo.x;
                            const dy = e.clientY - pointerDownInfo.y;
                            if (dx * dx + dy * dy > 8 * 8) {
                                if (measurementEl)
                                    measurementEl.style.display = "none";
                            }
                            return;
                        }

                        // Auto-highlight on hover
                        if (hoverTimeout) clearTimeout(hoverTimeout);
                        hoverTimeout = setTimeout(() => {
                            if (!selected && !state.measureMode) {
                                try {
                                    const world = toWorld(e);
                                    const worldPerPixel =
                                        (state.camera.top -
                                            state.camera.bottom) /
                                        container.getBoundingClientRect()
                                            .height;
                                    const threshold = Math.max(
                                        1e-6,
                                        10 * worldPerPixel,
                                    );
                                    const nearest = findNearestLocal(
                                        world,
                                        threshold,
                                    );

                                    if (nearest) {
                                        const kind = nearest.kind;
                                        if (kind === "line") {
                                            makeHighlightLine(
                                                nearest.segment.a.x,
                                                nearest.segment.a.y,
                                                nearest.segment.b.x,
                                                nearest.segment.b.y,
                                                0xff4444,
                                            );
                                        } else if (kind === "polyline") {
                                            makeHighlightLine(
                                                nearest.segment.a.x,
                                                nearest.segment.a.y,
                                                nearest.segment.b.x,
                                                nearest.segment.b.y,
                                                0xff4444,
                                            );
                                        } else if (kind === "circle") {
                                            makeHighlightCircle(
                                                nearest.meta.center,
                                                nearest.meta.radius,
                                                0xff4444,
                                            );
                                        }
                                    } else {
                                        clearHighlight();
                                    }
                                } catch (err) {
                                    // Silently ignore hover errors
                                }
                            }
                        }, 50);
                    },
                    { passive: true },
                );

                // Clear hover highlight when mouse leaves canvas
                state.renderer.domElement.addEventListener(
                    "mouseleave",
                    () => {
                        if (hoverTimeout) clearTimeout(hoverTimeout);
                        if (!selected) clearHighlight();
                    },
                    { passive: true },
                );
            })();

            // =============================
            // MEASURE TOOL - PROFESSIONAL VERSION
            // =============================
            (function initMeasureTool() {
                const measureBtn = document.getElementById("measureBtn");
                const measureToolbar =
                    document.getElementById("measureToolbar");
                const measureInstructions = document.getElementById(
                    "measureInstructions",
                );
                const measureResult = document.getElementById("measureResult");
                const cancelMeasure = document.getElementById("cancelMeasure");

                let measureState = {
                    point1: null,
                    point2: null,
                    visualGroup: null,
                    dragging: null, // { point: 'p1' | 'p2', offset: {x, y} }
                    snapRadius: 15, // pixels - radius to snap to geometry
                    placingFirstPoint: false,
                    placingSecondPoint: false,
                };

                // Find nearest snap point (endpoint, center, etc)
                function findSnapPoint(worldPos, pixelRadius) {
                    const h = state.renderer.domElement.height || 1;
                    const worldPerPixel =
                        (state.camera.top - state.camera.bottom) /
                        (state.camera.zoom || 1) /
                        h;
                    const snapDistance = pixelRadius * worldPerPixel;

                    let bestSnap = null;
                    let bestDist = Infinity;

                    for (const child of state.group.children) {
                        const ud = child.userData || {};
                        if (!ud.type) continue;

                        if (ud.type === "line") {
                            // Check endpoints
                            const d1 = Math.hypot(
                                worldPos.x - ud.a.x,
                                worldPos.y - ud.a.y,
                            );
                            const d2 = Math.hypot(
                                worldPos.x - ud.b.x,
                                worldPos.y - ud.b.y,
                            );
                            if (d1 < bestDist && d1 < snapDistance) {
                                bestDist = d1;
                                bestSnap = {
                                    x: ud.a.x,
                                    y: ud.a.y,
                                    type: "endpoint",
                                };
                            }
                            if (d2 < bestDist && d2 < snapDistance) {
                                bestDist = d2;
                                bestSnap = {
                                    x: ud.b.x,
                                    y: ud.b.y,
                                    type: "endpoint",
                                };
                            }
                            // Check midpoint
                            const midX = (ud.a.x + ud.b.x) / 2;
                            const midY = (ud.a.y + ud.b.y) / 2;
                            const dMid = Math.hypot(
                                worldPos.x - midX,
                                worldPos.y - midY,
                            );
                            if (dMid < bestDist && dMid < snapDistance) {
                                bestDist = dMid;
                                bestSnap = {
                                    x: midX,
                                    y: midY,
                                    type: "midpoint",
                                };
                            }
                        } else if (ud.type === "circle") {
                            // Check center
                            const dc = Math.hypot(
                                worldPos.x - ud.center.x,
                                worldPos.y - ud.center.y,
                            );
                            if (dc < bestDist && dc < snapDistance) {
                                bestDist = dc;
                                bestSnap = {
                                    x: ud.center.x,
                                    y: ud.center.y,
                                    type: "center",
                                };
                            }
                        } else if (ud.type === "polyline" && ud.pts) {
                            // Check all vertices
                            for (const pt of ud.pts) {
                                const d = Math.hypot(
                                    worldPos.x - pt.x,
                                    worldPos.y - pt.y,
                                );
                                if (d < bestDist && d < snapDistance) {
                                    bestDist = d;
                                    bestSnap = {
                                        x: pt.x,
                                        y: pt.y,
                                        type: "vertex",
                                    };
                                }
                            }
                        }
                    }

                    return bestSnap;
                }

                // Create simple small point marker (single points for handles)
                function createPointMarker(x, y, color, size = 4) {
                    // Create a single vertex Points object; size is in screen pixels (sizeAttenuation = false)
                    const geom = new THREE.BufferGeometry();
                    const pos = new Float32Array([x, y, 0]);
                    geom.setAttribute(
                        "position",
                        new THREE.BufferAttribute(pos, 3),
                    );

                    const material = new THREE.PointsMaterial({
                        color: color,
                        size: size,
                        sizeAttenuation: false,
                        depthTest: false,
                    });

                    const point = new THREE.Points(geom, material);
                    point.renderOrder = 999;
                    return point;
                }

                // Create a world-space circle around (x,y) that scales with camera zoom.
                // pixelRadius is the desired radius in screen pixels; we convert to world units.
                function createWorldCircle(
                    x,
                    y,
                    color,
                    pixelRadius = 12,
                    segments = 24,
                ) {
                    if (!state || !state.camera || !state.renderer) {
                        // fallback: no camera yet — return an empty group
                        const g = new THREE.Group();
                        return g;
                    }
                    // compute world units per pixel based on orthographic camera and current zoom
                    const h = state.renderer.domElement.height || 1;
                    const zoom = state.camera.zoom || 1;
                    const worldPerPixel =
                        (state.camera.top - state.camera.bottom) / (zoom * h);

                    const worldRadius = Math.max(
                        0.0001,
                        pixelRadius * worldPerPixel,
                    );

                    const geom = new THREE.BufferGeometry();
                    const positions = new Float32Array((segments + 1) * 3);
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        positions[i * 3 + 0] =
                            x + Math.cos(angle) * worldRadius;
                        positions[i * 3 + 1] =
                            y + Math.sin(angle) * worldRadius;
                        positions[i * 3 + 2] = 0;
                    }
                    geom.setAttribute(
                        "position",
                        new THREE.BufferAttribute(positions, 3),
                    );
                    const mat = new THREE.LineBasicMaterial({
                        color: color,
                        linewidth: 1,
                        depthTest: false,
                    });
                    const loop = new THREE.LineLoop(geom, mat);
                    loop.renderOrder = 999;
                    return loop;
                }

                // Create snap indicator (cross) sized in screen pixels and converted to world units
                function createSnapIndicator(x, y, pixelSize = 6) {
                    if (!state || !state.camera || !state.renderer) {
                        // Fallback if camera/renderer not ready
                        pixelSize = Math.max(1, pixelSize);
                    }
                    const h = state.renderer?.domElement?.height || 1;
                    const zoom = state.camera?.zoom || 1;
                    // Convert desired pixel size to world units for current zoom
                    const worldPerPixel =
                        (state.camera.top - state.camera.bottom) / (zoom * h);
                    const size = Math.max(0.0001, pixelSize * worldPerPixel);
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        x - size,
                        y,
                        0,
                        x + size,
                        y,
                        0,
                        x,
                        y - size,
                        0,
                        x,
                        y + size,
                        0,
                    ]);
                    geometry.setAttribute(
                        "position",
                        new THREE.BufferAttribute(positions, 3),
                    );
                    const material = new THREE.LineBasicMaterial({
                        color: 0xff9900,
                        linewidth: 1,
                        depthTest: false,
                        transparent: true,
                        opacity: 0.9,
                    });
                    const cross = new THREE.LineSegments(geometry, material);
                    cross.renderOrder = 998;
                    return cross;
                }

                // Update visual representation
                function updateMeasureVisuals() {
                    // Clear old visuals
                    if (measureState.visualGroup) {
                        state.overlayGroup.remove(measureState.visualGroup);
                        measureState.visualGroup.traverse((obj) => {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                    }

                    measureState.visualGroup = new THREE.Group();
                    state.overlayGroup.add(measureState.visualGroup);

                    const p1 = measureState.point1;
                    const p2 = measureState.point2;

                    if (!p1) return;

                    // Draw first point (small simple point marker)
                    const point1 = createPointMarker(p1.x, p1.y, 0x00ff00);
                    measureState.visualGroup.add(point1);

                    // Also add a world-space circle that scales with zoom (keeps consistent appearance)
                    const circle1 = createWorldCircle(
                        p1.x,
                        p1.y,
                        0x00ff00,
                        6,
                        24,
                    );
                    measureState.visualGroup.add(circle1);

                    if (p1.snap) {
                        const snapInd = createSnapIndicator(p1.x, p1.y);
                        measureState.visualGroup.add(snapInd);
                    }

                    if (p2) {
                        // Draw second point (small simple point marker)
                        const point2 = createPointMarker(p2.x, p2.y, 0x00ff00);
                        measureState.visualGroup.add(point2);

                        // Also add a world-space circle for second point
                        const circle2 = createWorldCircle(
                            p2.x,
                            p2.y,
                            0x00ff00,
                            6,
                            24,
                        );
                        measureState.visualGroup.add(circle2);

                        if (p2.snap) {
                            const snapInd = createSnapIndicator(p2.x, p2.y);
                            measureState.visualGroup.add(snapInd);
                        }

                        // Draw line
                        const lineGeom = new THREE.BufferGeometry();
                        lineGeom.setAttribute(
                            "position",
                            new THREE.BufferAttribute(
                                new Float32Array([
                                    p1.x,
                                    p1.y,
                                    0,
                                    p2.x,
                                    p2.y,
                                    0,
                                ]),
                                3,
                            ),
                        );
                        const lineMat = new THREE.LineBasicMaterial({
                            color: 0x00ff00,
                            linewidth: 2,
                            depthTest: false,
                        });
                        const line = new THREE.Line(lineGeom, lineMat);
                        line.renderOrder = 997;
                        measureState.visualGroup.add(line);

                        // Calculate and display distance
                        const distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                        measureInstructions.textContent = "Distância medida:";
                        measureResult.textContent =
                            distance.toFixed(3) + " unidades";
                    }
                }

                function activateMeasureMode() {
                    state.measureMode = true;
                    measureState.point1 = null;
                    measureState.point2 = null;
                    measureState.dragging = null;
                    measureState.placingFirstPoint = true;
                    measureBtn.classList.add("active");
                    measureToolbar.classList.add("active");
                    measureInstructions.textContent =
                        "Mova o mouse e clique para colocar o primeiro ponto";
                    measureResult.textContent = "";
                    // Disable orbit controls during measurement
                    if (state.controls) state.controls.enabled = false;
                }

                function deactivateMeasureMode() {
                    state.measureMode = false;
                    measureState.point1 = null;
                    measureState.point2 = null;
                    measureState.dragging = null;
                    measureState.placingFirstPoint = false;
                    measureState.placingSecondPoint = false;
                    if (measureState.visualGroup) {
                        state.overlayGroup.remove(measureState.visualGroup);
                        measureState.visualGroup = null;
                    }
                    measureBtn.classList.remove("active");
                    measureToolbar.classList.remove("active");
                    // Re-enable orbit controls
                    if (state.controls) state.controls.enabled = true;
                }

                function resetMeasure() {
                    measureState.point1 = null;
                    measureState.point2 = null;
                    measureState.dragging = null;
                    measureState.placingFirstPoint = true;
                    if (measureState.visualGroup) {
                        state.overlayGroup.remove(measureState.visualGroup);
                        measureState.visualGroup = null;
                    }
                    measureInstructions.textContent =
                        "Mova o mouse e clique para colocar o primeiro ponto";
                    measureResult.textContent = "";
                }

                measureBtn.addEventListener("click", () => {
                    if (state.measureMode) {
                        deactivateMeasureMode();
                    } else {
                        activateMeasureMode();
                    }
                });

                cancelMeasure.addEventListener("click", () => {
                    resetMeasure();
                });

                // Update measure visuals when camera or controls change (so world-space circle scales properly)
                if (
                    state.controls &&
                    typeof state.controls.addEventListener === "function"
                ) {
                    state.controls.addEventListener("change", () => {
                        try {
                            if (measureState && measureState.visualGroup) {
                                updateMeasureVisuals();
                            }
                        } catch (e) {
                            // ignore
                        }
                    });
                }

                // Mouse move - cursor tracking and dragging
                state.renderer.domElement.addEventListener(
                    "pointermove",
                    (e) => {
                        if (!state.measureMode) return;

                        try {
                            const world = state.toWorld(e);
                            const snap = findSnapPoint(
                                world,
                                measureState.snapRadius,
                            );
                            const finalPos = snap || world;

                            if (measureState.dragging) {
                                // Dragging a point
                                if (measureState.dragging.point === "p1") {
                                    measureState.point1 = {
                                        x: finalPos.x,
                                        y: finalPos.y,
                                        snap: snap,
                                    };
                                } else if (
                                    measureState.dragging.point === "p2"
                                ) {
                                    measureState.point2 = {
                                        x: finalPos.x,
                                        y: finalPos.y,
                                        snap: snap,
                                    };
                                }
                                updateMeasureVisuals();
                            } else if (measureState.placingFirstPoint) {
                                // First point follows cursor
                                measureState.point1 = {
                                    x: finalPos.x,
                                    y: finalPos.y,
                                    snap: snap,
                                    preview: true,
                                };
                                updateMeasureVisuals();
                            } else if (measureState.placingSecondPoint) {
                                // Second point follows cursor
                                measureState.point2 = {
                                    x: finalPos.x,
                                    y: finalPos.y,
                                    snap: snap,
                                    preview: true,
                                };
                                updateMeasureVisuals();
                            }

                            // Update cursor style
                            if (snap) {
                                state.renderer.domElement.style.cursor =
                                    "crosshair";
                            } else if (measureState.dragging) {
                                state.renderer.domElement.style.cursor = "move";
                            } else {
                                state.renderer.domElement.style.cursor =
                                    "default";
                            }
                        } catch (err) {
                            console.error("Measure move error:", err);
                        }
                    },
                    { passive: true },
                );

                // Mouse down - start drag or place point
                state.renderer.domElement.addEventListener(
                    "pointerdown",
                    (e) => {
                        if (!state.measureMode) return;
                        e.stopPropagation();

                        try {
                            const world = state.toWorld(e);

                            // Check if clicking on existing point to drag
                            const dragRadius = 20; // pixels
                            const h = state.renderer.domElement.height || 1;
                            const worldPerPixel =
                                (state.camera.top - state.camera.bottom) /
                                (state.camera.zoom || 1) /
                                h;
                            const dragDist = dragRadius * worldPerPixel;

                            if (
                                measureState.point1 &&
                                !measureState.point1.preview
                            ) {
                                const d1 = Math.hypot(
                                    world.x - measureState.point1.x,
                                    world.y - measureState.point1.y,
                                );
                                if (d1 < dragDist) {
                                    measureState.dragging = { point: "p1" };
                                    return;
                                }
                            }

                            if (
                                measureState.point2 &&
                                !measureState.point2.preview
                            ) {
                                const d2 = Math.hypot(
                                    world.x - measureState.point2.x,
                                    world.y - measureState.point2.y,
                                );
                                if (d2 < dragDist) {
                                    measureState.dragging = { point: "p2" };
                                    return;
                                }
                            }
                        } catch (err) {
                            console.error("Measure down error:", err);
                        }
                    },
                );

                // Mouse up - confirm point placement or end drag
                state.renderer.domElement.addEventListener("pointerup", (e) => {
                    if (!state.measureMode) return;

                    try {
                        if (measureState.dragging) {
                            // End drag
                            measureState.dragging = null;
                            state.renderer.domElement.style.cursor = "default";
                            return;
                        }

                        // Place points in sequence
                        if (measureState.placingFirstPoint) {
                            // Confirm first point
                            if (measureState.point1) {
                                measureState.point1.preview = false;
                                measureState.placingFirstPoint = false;
                                measureState.placingSecondPoint = true;
                                measureInstructions.textContent =
                                    "Mova o mouse e clique para colocar o segundo ponto";
                                console.log(
                                    "[MEASURE] P1 placed:",
                                    measureState.point1,
                                );
                            }
                        } else if (measureState.placingSecondPoint) {
                            // Confirm second point
                            if (measureState.point2) {
                                measureState.point2.preview = false;
                                measureState.placingSecondPoint = false;
                                const distance = Math.hypot(
                                    measureState.point2.x -
                                        measureState.point1.x,
                                    measureState.point2.y -
                                        measureState.point1.y,
                                );
                                measureInstructions.textContent =
                                    "Medição concluída - Arraste os pontos para ajustar";
                                console.log(
                                    "[MEASURE] P1:",
                                    measureState.point1,
                                    "P2:",
                                    measureState.point2,
                                    "Distance:",
                                    distance,
                                );
                            }
                        }
                    } catch (err) {
                        console.error("Measure up error:", err);
                    }
                });
            })();

            // Optional: auto-load a DXF when served via HTTP (uncomment to use)
            // loadUrl(new URL("examples_dxf/bridge.dxf", window.location.href).href).catch(console.warn);
        </script>
    </body>
</html>
